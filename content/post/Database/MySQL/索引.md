---
title: "MySQL 索引详解"
date: 2021-02-06 00:00:00
categories:
  - MySQL
tags:
  - Database
  - MySQL
series:	
  - 面试大全
---

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

<!--more-->

## 索引模型

**优点**：

1. 能大大的加快数据库中查询的速度。

**缺点**：

1. 索引会占用额外的存储空间，如果创建索引过多，占用空间会很大。
2. 在对建立了索引的表中写入数据时，索引需要动态的维护。也就是说，会影响写入数据的效率。

**注意事项**：

1. 避免给经常更新的表建立太多索引，以免影响太多写入效率。
2. 建立索引的字段，越短越好，数值类型越简单越好。
3. 尽量避免字段中出现 `NULL`，因为 `NULL` 值的查询是不走索引的，含空值的列是很难做查询优化的。所以要在建立字段时加上 `NOT NULL` 的约束条件，空值用 `0` 或者空字符代替。
4. 索引不要盲目建立，一般只需要给在 `WHERE` 和 `JOIN` 字句中需要出现的字段建立索引即可。
5. 建立索引后，查询的时候不要进行运算，因为运算的话会变成全表查询。只有这些运算符：`<`，`<=`，`=`，`>`，`>=`，`BETWEEN`，`IN`，以及某些时候的`LIKE`会被索引支持。

**索引类型**

索引是在存储引擎中实现的，不同的存储引擎有不同的索引方式。常用的 `InnoDB` 和 `MyISAM` 引擎都只能使用 `B-tree` 索引。

根据索引的使用方式，分为`单列索引`、`组合索引`、`全文索引`和`空间索引`，这其中单例索引又分为`普通索引`、`唯一索引`和`主键索引`。

### 常见索引模型

常见的三种索引模型分别是哈希表、有序数组和搜索树。

- 哈希表：由于哈希表存储数据是无序的，所以适用于等值查询，不适用于范围查询，效率很低。
- 有序数组：由于是有序的，等值查询可以用二分法，所以等值查询和范围查询都适合。但更新数据效率很低。
- 搜索树：根据搜索需求逐渐演变，从二叉树到 N 叉树。N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

## 单列索引

在 InnoDB 中，表根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。同时，InnoDB 使用了 B+ 树索引模型，所以数据都存储在 B+ 树中。

每一个索引在 InnoDB 里面对应一棵 B+ 树。

### 普通索引

以下是创建普通索引三种的方式：

```mysql
CREATE INDEX indexName ON tbname(colname(length));
```

```mysql
ALTER table tableName ADD INDEX indexName(colname);
```

```mysql
CREATE TABLE tbname(
ID INT NOT NULL,
username VARCHAR(16) NOT NULL,
INDEX [indexName] (colname(length))
);  
```

创建索引时，如果字段是 `CHAR`，`VARCHAR` 类型，`length` 可以小于字段实际长度。如果是`BLOB`和`TEXT`类型，必须指定 `length`。

同时，索引的名字也是可选的，如果没有指定名字的话，那么 `MySQL` 会默认用字段名作为索引的名字。

索引建好之后，可以使用以下命令查看：

```mysql
SHOW INDEX FROM table_name;
```

同样也可以使用以下命令删除普通索引：

```mysql
DROP INDEX [indexName] ON table_name; 
```

### 唯一索引

在 `MySQL` 之中，有一个比较特殊的地方就是，`KEY` 和 `INDEX` 常常被混淆在一起，虽然说本质上 `KEY` 和 `INDEX` 不是同一个东西，但是究其原因，`MySQL` 中的约束效果是通过索引来实现的，`MySQL`数据库判断是否当前列是否 unique 就是通过 unique 索引判断的。

因为这个原因，所以其实我们的 `UNIQUE KEY` 约束条件其实也就建立了索引，两者被完全绑定到了一起。

以下是建立唯一索引的方式：

```mysql
CREATE UNIQUE INDEX indexName ON tablename(colname(length));
```

```mysql
ALTER TABLE table_name ADD UNIQUE indexName ON (colname(length));
```

```mysql
CREATE TABLE table (
id int NOT NULL AUTO_INCREMENT,
name varchar(20) NOT NULL,
UNIQUE [indexName] (colname(length))
);
```

唯一索引的删除方式与普通索引是一致的。

### 主键索引

主键索引也是类似，与主键这个约束条件基本是相同的，创建的方式与主键通用，就不一一赘述了。

这里主要讲一讲 `InnoDB` 引擎上主键的选择。在没有特殊需求的情况下，主键都应该使用无关业务逻辑的自增字段。

有人会觉得，使用身份证之类的数据来作为主键也是可以的，但是在算法层面上，如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样会形成一个紧凑的索引结构，提高效率。

而如果使用的是身份证号这种非自增数据的话，那么数据的值就是类似随机的数据，就达不到这个效果了。

### 主键索引和普通索引

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（`clustered index`）。

- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（`secondary index`）。

**基于主键索引和普通索引的查询区别：**

- 如果语句是 `select * from T where ID=500`，即主键查询方式，则只需要搜索 ID 这棵 B+ 树。
- 如果语句是 `select * from T where k=5`，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，在应用中应该尽量使用主键查询。

**为什么要使用自增主键：**

- 每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

  而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

- 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

## 组合索引

组合索引其实就是用多个字段做一个索引，在查询时如果有多个字段做为索引条件的话，那么组合索引的效率会大大高于每个字段做一个单列索引。

因为 `MySQL` 的查询每次只能使用一个索引，所以多个单列索引只会用到一个索引，其他字段的查询就会变成全文搜索。

建立组合索引的方式：

```mysql
CREATE INDEX indexname On tbName(colname(length),colname(length),...);
```

```mysql
ALTER TABLE tbname ADD INDEX indexname (colname(length),colname(length),...);
```

### 覆盖索引

如果查询的值已经在索引树上了，则可以直接提供查询结果，不需要回表，可以减少数的搜索次数。这种情况被称为覆盖索引，是一种常用的性能优化手段。

而通过联合索引，可以将需要查询的值放到索引上，用于加速查询效率。

例如，如果要根据市民的身份证号查询他的姓名，那么可以建立一个（身份证号、姓名）的联合索引。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

### 最左前缀

B+ 树中，索引项是按照索引定义里面出现的字段顺序排序的。由于 B+ 树这种索引结构，可以利用索引的`最左前缀`，来定位记录。

这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。只要满足最左前缀，就可以利用索引来加速检索。

**如何安排联合索引字段顺序？**

评估标准是，索引的复用能力。

因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

### 索引下推

在搜索时，如果满足最左前缀原则，则可以直接在索引上定位记录。

在 MySQL 5.6 之前，如果有不满足最左前缀原则的搜索条件，只能先根据最左前缀索引找出所有匹配的记录，然后逐条数据开始一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（`index condition pushdown`)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再开始回表查询，减少了回表次数。

