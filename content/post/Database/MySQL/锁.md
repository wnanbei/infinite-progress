---
title: "MySQL 中的锁"
date: 2021-02-06 00:00:00
categories:
  - MySQL
tags:
  - Database
  - MySQL
series:	
  - 面试大全
---

根据加锁的范围，MySQL 的锁大致可以分成三类：

1. 全局锁
2. 表锁
3. 行锁

<!--more-->

根据加锁的方式，锁通常分为两类：

1. 读锁（read lock），也叫共享锁（shared lock）

   针对同一份数据，多个读操作可以同时进行而不会互相影响（select），只会阻塞写操作

2. 写锁（write lock），也叫排他锁（exclusive lock）

   当前操作没完成之前，会阻塞其它读和写操作（update、insert、delete）

## 全局锁

MySQL 提供一个加全局读锁的方法，命令是 `Flush tables with read lock (FTWRL)`。

此命令可以让整个库处于只读状态，之后其他线程的以下语句会被阻塞：

- 数据更新语句（数据的增删改）
- 数据定义语句（包括建表、修改表结构等）
- 更新类事务的提交语句

全局锁的典型使用场景是做全库逻辑备份。

## 表锁

表锁的语法是 `lock tables … read/write`。可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。

注：lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

### 特点

- 对整张表加锁 
- 开销小
- 加锁快
- 无死锁
- 锁粒度大，发生锁冲突概率大，并发性低

## MDL 元数据锁

元数据锁（`metadata lock`）是一种表级锁。

MDL 的作用是，确保读取数据时，表结构不会被修改，保证读写的正确性。MDL 不需要显式使用，每执行一条 DML、DDL 语句时都会申请 MDL 锁。

- 对表做增删改查操作的时候，加 MDL 读锁

  读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

- 对表做结构变更操作的时候，加 MDL 写锁

  读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

### 特点

- 事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。
- MDL 锁实现于 MySQL 的 server 层。
- 申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。

### 版本

- MySQL 5.5 版本中引入 MDL

## 行锁

MySQL 行锁由引擎层实现，InnoDB 支持行锁，MyISAM 不支持。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

### 特点

- 对一行数据加锁
- 开销大
- 加锁慢
- 会出现死锁
- 锁粒度小，发生锁冲突概率最低，并发性高

### 优化

1. 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

## 死锁

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

### 处理策略

出现死锁以后，有两种策略：

1. **直接进入等待，直到超时。**

   这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。

   在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

2. **发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。**

   将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，此参数默认为 on。

### 死锁检测

死锁检测是一个时间复杂度是 O(n) 的操作。每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁。如果大量并非要修改同一行数据，会消耗大量的 CPU 资源。

解决由这种热点行更新导致的性能问题，有以下几个方案：

1. **确保业务一定不会出现死锁的情况下，临时关闭死锁检测。**

   这种操作本身带有一定的风险，因为关闭死锁检测意味着可能会出现大量的超时，这是业务有损的。

2. **控制并发度。**

   如果同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。可以从以下几个方向控制并发度：

   - 数据库服务端硬性限制并发线程数量
   - 将一行数据横向拆分成多行，比如账户总额拆分成 10 行，总额由 10 行数据相加得到

## 间隙锁

为了解决幻读问题，InnoDB 引入了间隙锁 (`Gap Lock`)。间隙锁指的是将两条相连数据间的位置锁住，不能插入数据。

行锁和间隙锁组合起来，就叫做 `next-key lock`。

间隙锁是一个在索引记录之间的间隙上的锁，使用间隙锁，检索条件必须有索引。没有索引 MySQL 会全表扫描，锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加。

### 加锁规则

1. 加锁的基本单位是 next-key lock，是前开后闭区间。
2. 查找过程中访问到的对象才会加锁。
3. 索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
4. 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

