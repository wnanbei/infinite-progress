---
title: "防御性编程"
date: 2021-11-12
categories:
  - Go语言规范
tags:
  - Go
series:
---

**防御性编程**（Defensive programming）是**防御**式设计的一种具体体现，它是为了保证，对程序的不可预见的使用，不会造成程序功能上的损坏。

它可以被看作是为了减少或消除墨菲定律效力的方法。

<!--more-->

> 一个测试工程师走进一家酒吧，要了一杯啤酒；
>
> 一个测试工程师走进一家酒吧，要了一杯咖啡；
>
> 一个测试工程师走进一家酒吧，要了-1杯啤酒；
>
> 一个测试工程师走进一家酒吧，要了一份asdfQwer@24dg!&*(@；
>
> 一个测试工程师走进一家酒吧，什么也没要；
>
> 一个测试工程师走进一家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿；
>
> 一个测试工程师走进一家酒吧，要了NaN杯Null；
>
> 一个测试工程师冲进一家酒吧，要了500吨啤酒；
>
> 一个测试工程师把酒吧拆了；
>
> 一个测试工程师化装成老板走进一家酒吧，要了500杯啤酒并且不付钱；
>
> 一万个测试工程师在酒吧门外呼啸而过；
>
> **测试工程师们满意地离开了酒吧。**
>
> **然后一名顾客点了一份炒饭，酒吧炸了。**

这就是今天的主题，~~如何避免酒吧爆炸~~ 防御性编程。类似的概念有防御性驾驶、防御性专利。

## 防御性编程的特点

### 不信任原则

软件开发的不信任原则，保持 overly pessimistic（过于悲观），把和程序有关的一切请求、服务、接口、返回值、机器、框架、中间件等等都当做不可信的，步步为营、处处设防。 

### *边界和场景

**边界：**

- **用户端的输入和操作**
- **网络环境**
- **数据存储**
- 文件
- 第三方包
- 同事写的代码
- 自己写的代码

**场景：**

- 非常规操作，如：高频点击、非流程操作

### 缺点

- 部分性能损失。
- 健壮性的损失。
- 代码可读性的损失。
- 开发时间的损耗（不一定）。

### 优点

- 尽早发现较小的问题，而不是等到它们发展成大的灾难的时候才发现。
- 节省大量调试时间。
- 避免异常逻辑的传导，明确异常原因与位置。
- 避免了大量安全性问题，防范部分恶意的滥用。

### *健壮性与正确性的平衡

正确性（correctness）意味着永不返回不准确的结果，哪怕不返回结果也比返回不准确的结果好。

健壮性（robustness）意味着要不断尝试采取某些措施，以保证软件可以持续地运转下去，哪怕有时得出一些不够准确的结果。

## 实践场景

### 良好的编程风格和合理的设计

良好的编程风格、合理的结构设计可以使编码变得更加清晰明了，很轻松的将大部分可能发生的问题消弥在无形之中。

所以，先思考，后编码会是一个非常良好的习惯，也是防御性编程的基础。

### 参数验证

目前后端遇最需要防御性编程的情况，应该是 api 接口的请求参数需要验证。参数的上下限、数值类型、零值、类型、格式等等都需要进行验证。

这些错误有可能来自于用户的错误使用，也可能来自于前端的异常调用，保护我们的程序远离外部的无效数据，可以大大提高程序的稳定性。

Gin 框架在使用 `Bind` 系列方法绑定 struct 时会自动根据 struct 的 tag 来验证参数是否正确，用来验证的库是：`go-playground/validator/v10`，这里有详细用法：[validator](https://pkg.go.dev/github.com/go-playground/validator/v10#section-readme)。

```go
type Test struct {
	Field `binding:"required"`           //此字段值必须存在
	Field `binding:"omitempty,rgb|rgba"` //此字段值可以不存在，仅在存在时验证格式
	Field `binding:"min=2,max=10"`       //限制数值类型大小、字符串类型长度、切片元素数量
	Field `binding:"boolean"`            //限制为 bool 类型
	Field `binding:"number"`             //限制为数字
	Field `binding:"email"`              //限制为邮箱格式
}
```

如果对于绑定时自动验证的方式不满足，或者需要在其他地方使用，可以单独使用 `validator` 库。

需要注意的是，单独使用时，tag 需要使用 `validate` 而不是 `binding`：

```go
type Test struct {
	Field string `validate:"number"`
}

func main() {
	validate := validator.New()

	t := &Test{Field: "abcd"}
	err := validate.Struct(t)
	if err != nil {
		fmt.Println(err)
	}
}
```

也可以单独验证一个字段：

```go
validate := validator.New()
s := "18"
err := validate.Var(s, "min=5,max=10")
if err != nil {
  fmt.Println(err)
}
```

使用 `validator` 验证 struct 时，返回的异常可以清晰的说明是哪个字段出了什么问题，根据不同的异常返回不同的提示信息，可以更好的提升接口的清晰性、正确性。

### dao 层参数验证

除了 api 接口的参数异常属于高危情况外，访问数据的 dao 层接受的参数同样需要严格的参数验证，这种情况不仅关系到代码正常运行，更影响到整个系统、业务的安全。

dao 层接收到的参数可能来自于程序内部的错误处理、api 接口未过滤的异常参数等情况，但由于直面数据库，造成严重后果的可能性更大，所以更要谨慎验证参数的正确性。

### 谨慎强制类型转换

一定要对于强制的类型转换保持警惕，如果转换方法会返回异常的，一定要处理异常，并预设转换失败的场景进行处理。

以下是一些常见的类型转换高危场景：

- int64 转 int32，有可能造成精度的丢失；
- **string 转 int，格式异常转换失败；**
- string 转 time.Time，格式异常转换失败；
- **解析 json，格式异常转换失败。**

### 异常处理

Go 语言处理所有异常的理念，是非常符合防御式编程的思想的。不要预设异常不会发生而忽略异常。

而异常的处理方法则需要根据业务的具体情况具体分析，常见的处理方法有以下几类：

- 返回中立值
- 换用下一个正确数据
- 返回与前一次相同的值
- 换用最接近的有效值
- 在日志中记录告警信息
- 返回错误码
- 调用错误处理子程序或对象
- 关闭程序

除此之外，像 gin 的默认中间件 `Recovery` 中间件会自动恢复所有 api 中的 panic，并记录日志，这也是一种防御性编程的方式。

### *方法返回数据的验证

再次强调，不要信任任何方法的返回值。在异常处理的基础上，还需要验证返回的数据是否正确，某些重要的数据是否存在，数据是否正常。



### 好的 API 设计

这个 API 不仅指的是我们的 Restful api 接口，也指的是我们内部代码的方法 API。

- 好的 API 易于使用：命名合理、可读性强，输入输出设置合理且扩展性好。
- 好的 API 难以误用：针对各种可能的误用情况进行必要校验并给出可读性强的报错信息提示。

当 API 的设计良好，同时保证了易于使用和难以误用时，自然会大大提高 API 的正确使用率，降低各种因为 API 误用造成的问题。

### 频率控制

特别是消耗过于大的方法场景

同时保护被调用方的频率。令牌桶、漏桶

- 用户流控：限制每个用户在一定时间内对某个接口的调用数。

- 接口流控：限制一定时间内某个接口的总调用数。

- 单机流控：限制一定时间内单台服务器上的项目所有接口的总调用数。

- 分布式流控：限制一定时间内项目所有服务器的总请求数。 

### 包变量私有化

不需要被外部使用的包变量，使用首字母小写的私有变量，如果外部需要访问，也尽量使用全局方法提供给外部访问。避免包变量在外部被错误修改，导致程序的异常。

```go
const (
	env = "prod"
)

func Env() string {
	return env
}
```

如果包变量需要被外部变更，特别是一些比较复杂的对象，更要使用包提供的方法去进行安全的变更。

```go
func ChangeEnv() error {
	if v, ok := checkConfig(); ok {
		env = v
		return nil
	}
	return errors.New("change env failed.")
}
```

### 尽量使用常量替代全局变量

如果某些全局变量不需要修改，那么使用常量来声明这些变量，利用常量不可更改的属性来保护这些变量的值不被他人变更。

```go
const (
	StatusContinue           = 100 // RFC 7231, 6.2.1
	StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2
)

var statusText = map[int]string{
	StatusContinue:           "Continue",
	StatusSwitchingProtocols: "Switching Protocols",
}

func StatusText(code int) string {
	return statusText[code]
}
```

### 超时控制

调用接口或长耗时任务，需要限制最大超时时间，并审慎地判断超时时间的值。如果超时时间过长，短时间并发量增大的情况下，会造成大量协程被挂起，消耗大量资源，造成系统异常。

Go 中可以使用 `context` 或 `time.After` 等机制对超时行为进行控制。

### *释放资源

在获取资源后，尽量使用 defer 释放资源。

在代码较简单的情况下，可以使用在每一个代码分支结束时手动释放资源。但在代码复杂起来，时间跨度拉长，变更了开发人员等情况下，某些代码分支没有释放资源而直接结束方法后。就会造成资源永久挂起、内存泄漏等问题。

简单的一个场景：一个 500 行的函数，需要你去检查一个 bug，你发现是少做了一层判断，你加上判断后，if err != nil { return }，看上去是不是很正常，那如果有资源需要手动释放的情况，这里就会造成内存泄漏。

同样的，反过来想，作为一个后来的代码维护者，在修改代码时，同样要注意检查是否有需要手动释放的资源。

### *隔离程序

这是对于防御性编程的灵活调整，毕竟防御性编程始终是有成本的。而**绝对防御**式编程将消耗大量的精力，造成非常臃肿的代码。

所以我们可以将高危、容易出错的地方加上防御性编程代码，而在不容易出错的、内部的位置减少或去掉防御性编程代码。

以下位置就是常见的高危场景：

- 外部输入
- 调用接口
- 文件访问
- 数据库查询

而在内部的函数调用等地方，可以适当的减少防御性代码，但某些关键数据和关键逻辑位置，防御性代码依然是必要的。

