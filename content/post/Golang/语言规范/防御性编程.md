---
title: "防御性编程"
date: 2021-11-12
categories:
  - Go语言规范
tags:
  - Go
series:
typora-root-url: ..\..\..\..\static
---

**防御性编程**（Defensive programming）是**防御**式设计的一种具体体现，它是为了保证，对程序的不可预见的使用，不会造成程序功能上的损坏。

它可以被看作是为了减少或消除墨菲定律效力的方法。

<!--more-->

> 一个测试工程师走进一家酒吧，要了一杯啤酒；
>
> 一个测试工程师走进一家酒吧，要了一杯咖啡；
>
> 一个测试工程师走进一家酒吧，要了 -1 杯啤酒；
>
> 一个测试工程师走进一家酒吧，要了一份 asdfQwer@24dg!&*(@；
>
> 一个测试工程师走进一家酒吧，什么也没要；
>
> 一个测试工程师走进一家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿；
>
> 一个测试工程师走进一家酒吧，要了 NaN 杯 Null；
>
> 一个测试工程师冲进一家酒吧，要了 500 吨啤酒；
>
> 一个测试工程师把酒吧拆了；
>
> 一个测试工程师化装成老板走进一家酒吧，要了 500 杯啤酒并且不付钱；
>
> 一万个测试工程师在酒吧门外呼啸而过；
>
> **测试工程师们满意地离开了酒吧。**
>
> **然后一名顾客点了一份炒饭，酒吧炸了。**

这就是今天的主题， ~~如何避免酒吧爆炸~~ 防御性编程。类似的概念有防御性驾驶、防御性专利。

## 防御性编程的概念

### 不信任原则

软件开发的不信任原则，保持 overly pessimistic（过于悲观），把和程序有关的一切请求、服务、接口、返回值、机器、框架、中间件等等都当做不可信的，步步为营、处处设防。 

我们常常提到的程序的高可用概念，其实也基于不信任原则，不信任各种软件程序、硬件设施的可用性，而使用备份、多副本等方法来提高整体系统的可用性。

### 边界和场景

以下是常见的一些适用于防御性编程的场景：

- **用户端的输入和操作**
- **网络环境**
- **数据存储**
- 非常规操作，如：高频点击、非流程操作
- 文件操作
- 调用第三方库提供的方法
- 调用同事写的方法
- 调用自己写的方法

### 缺点

但是使⽤防御性编程也并不是毫⽆缺点的，它需要我们做⼀些额外的操作，所以也是有⼀定缺点的:

- 部分性能损失
- 代码可读性的损失
- ~~开发时间的损耗~~

### 优点

- 尽早发现较小的问题，而不是等到它们发展成大的灾难的时候才发现
- 节省大量调试时间
- 避免异常逻辑的传导，明确异常原因与位置
- 避免了大量安全性问题，防范部分恶意的滥用
- 提高程序的健壮性

## 实践场景

### 良好的编程风格和合理的设计

良好的编程风格、合理的结构设计可以使编码变得更加清晰明了，很轻松的将大部分可能发生的问题消弥在无形之中。

所以，先思考，后编码会是一个非常良好的习惯，也是防御性编程的基础。

### 好的 API 设计

这里的 API 不仅指的是我们的 Restful api 接口，也指的是我们内部代码的方法 API。

- 好的 API 易于使用：命名合理、可读性强，输入输出设置合理且扩展性好。
- 好的 API 难以误用：针对各种可能的误用情况进行必要校验并给出可读性强的报错信息提示。

当 API 的设计良好，同时保证了易于使用和难以误用时，自然会大大提高 API 的正确使用率，降低各种因为 API 误用造成的问题。

### 参数验证

目前后端遇最需要防御性编程的情况，应该是 api 接口的请求参数需要验证。参数的上下限、数值类型、零值、类型、格式等等都需要进行验证。

这些错误有可能来自于用户的错误使用，也可能来自于前端的异常调用，保护我们的程序远离外部的无效数据，可以大大提高程序的稳定性。

Gin 框架在使用 `Bind` 系列方法绑定 struct 时会自动根据 struct 的 tag 来验证参数是否正确，用来验证的库是：`go-playground/validator/v10`，这里有详细用法：[validator](https://pkg.go.dev/github.com/go-playground/validator/v10#section-readme)。

```go
type Test struct {
	Field `binding:"required"`           //此字段值必须存在
	Field `binding:"min=2,max=10"`       //限制数值类型大小、字符串类型长度、切片元素数量
	Field `binding:"boolean"`            //限制为 bool 类型
	Field `binding:"number"`             //限制为数字
	Field `binding:"email"`              //限制为邮箱格式
	Field `binding:"omitempty,rgb|rgba"` //此字段值可以不存在，仅在存在时验证格式
}
```

如果对于绑定时自动验证的方式不满足，或者需要在其他地方使用，可以单独使用 `validator` 库。

需要注意的是，单独使用 validator 库时，tag 需要使用 `validate` 而不是 `binding`：

```go
type Test struct {
	Field string `validate:"number"`
}

func main() {
	validate := validator.New()

	t := &Test{Field: "abcd"}
	err := validate.Struct(t)
	if err != nil {
		fmt.Println(err)
	}
}
```

也可以单独验证一个字段：

```go
validate := validator.New()
s := "18"
err := validate.Var(s, "min=5,max=10")
if err != nil {
  fmt.Println(err)
}
```

使用 `validator` 验证 struct 时，返回的异常可以清晰的说明是哪个字段出了什么问题，根据不同的异常返回不同的提示信息，可以更好的提升接口的清晰性、正确性。

### dao 层参数验证

除了 api 接口的参数异常属于高危情况外，访问数据的 dao 层接受的参数同样需要严格的参数验证，这种情况不仅关系到代码正常运行，更影响到整个系统、业务的安全。

dao 层接收到的参数可能来自于程序内部的错误处理、api 接口未过滤的异常参数等情况，但由于直面数据库，造成严重后果的可能性更大，所以更要谨慎验证参数的正确性。

### 谨慎强制类型转换

一定要对于强制的类型转换保持警惕，如果转换方法会返回异常的，一定要处理异常，并预设转换失败的场景进行处理。

以下是一些常见的类型转换高危场景：

- **解析 json 数据，格式异常转换失败；**
- **string 转 int，格式异常转换失败；**
- 高精度数值转低精度数值，有可能造成精度的丢失，如：int64 转 int32、float64 转 float32；
- string 转 time.Time，格式异常转换失败；

### 异常处理

Go 语言处理所有异常的理念，是非常符合防御式编程的思想的。一定不要预设异常不会发生而忽略异常。

而异常的处理方法则需要根据业务的具体情况具体分析，常见的处理方法有以下几类：

- 返回中立值
- 换用下一个正确数据
- 返回与前一次相同的值
- 换用最接近的有效值
- 在日志中记录告警信息
- 返回错误码
- 调用错误处理子程序或对象
- 关闭程序

除此之外，像 gin 的默认中间件 `Recovery` 中间件会自动恢复 api 中的 panic，并记录日志，这也是一种防御性编程的方式。

### 返回数据的验证

再次强调，不要信任任何方法的返回的数据，不论是数据库数据的查询、函数方法的调用还是 Json 解析出的数据，未返回异常的数据错误更加致命，因为这往往意味着这种错误不在预料之中，并且在代码层面难以查找。

所以在异常处理的基础上，还需要验证返回的数据是否正确，某些重要的数据是否存在，格式是否正常，如 Python 之类的动态类型语言还需要判断变量的类型是否正确。

比如我们有一个查询 User 的方法：

```go
func FindUser(id int) (*User, error) {
	...
}
```

当我们需要这个 User 其中的部门信息时我们可能会这样写：

```go
user, err := FindUser(userID)
if err != nil {
	return nil, err
}
return user.Department, nil
```

那么可能在大多数情况下，这样的代码运行是正常的，因为根据 ID 查询用户，基本都是有这个 ID 才会去查，那自然返回的 `*User` 是有值的。但一旦某一天，查询的是一个不存在的 ID 时，这里就会抱错，而且是一个空指针异常。

所以，在做这类操作之前，最好再对数据做一层校验，以确保程序逻辑的完善：

```go
user, err := FindUser(userID)
if err != nil {
	return nil, err
}
if user == nil {
  return nil, error.New("user not exists")
}
return user.Department, nil
```

### 包变量私有化

不需要被外部使用的包变量，使用首字母小写的私有变量，如果外部需要访问，也尽量使用全局方法提供给外部访问。避免包变量在外部被错误修改，导致程序的异常。

```go
const (
	env = "prod"
)

func Env() string {
	return env
}
```

如果包变量需要被外部变更，特别是一些比较复杂的对象，更要使用包提供的方法去进行安全的变更。

```go
func ChangeEnv() error {
	if v, ok := checkConfig(); ok { //做一些检查、判断的工作
		env = v
		return nil
	}
	return errors.New("change env failed.")
}
```

### 尽量使用常量替代全局变量

如果某些全局变量不需要修改，那么使用常量来声明这些变量，利用常量不可更改的属性来保护这些变量的值不被他人变更。

```go
const (
	StatusContinue           = 100 // RFC 7231, 6.2.1
	StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2
)

var statusText = map[int]string{
	StatusContinue:           "Continue",
	StatusSwitchingProtocols: "Switching Protocols",
}

func StatusText(code int) string {
	return statusText[code]
}
```

### 超时控制

调用接口或长耗时任务，需要限制最大超时时间，并审慎地判断超时时间的值。如果超时时间过长，短时间并发量增大的情况下，会造成大量协程被挂起，消耗大量资源，造成系统异常。

Go 中可以使用 `context` 或 `time.After` 等机制对超时行为进行控制。

### 频率控制

超时控制在很多时候只能降低问题的发生概率，减缓问题的严重程度，而频率控制则能在无法降低操作耗时的情况下，基本维持住程序的可用性。

特别是一些操作消耗过大的场景，一定要在频率上进行限制，否则各种资源耗尽都会导致程序的不可运行。

而除了保护自己程序的可用性外，频率限制同时可以保护被调用方的可用性，避免出现自己扛得住，但把被调用方打挂了的情况。

频率控制成熟的算法有很多，比如令牌桶、漏桶，具体的实现各个语言也都有现成的第三方库，可以根据业务的具体类型选择适合的方式。

频率控制也分为不同的粒度，以下是一些常见的情况：

- 用户流控：限制每个用户在一定时间内对某个接口的调用数。

- 接口流控：限制一定时间内某个接口的总调用数。

- 单机流控：限制一定时间内单台服务器上的项目所有接口的总调用数。

- 分布式流控：限制一定时间内项目所有服务器的总请求数。 

### 自动释放资源

在程序中获取资源后，尽量使用语言特性自动释放资源，比如 Go 语言中可以使用 `defer`，Python 中可以使用 `with` 语法，在逻辑结束后，自动把资源释放掉。

```go
file, err := os.Open(path)
if err != nil {
  ...
}
defer file.Close()
```

手动释放资源，是极其不可靠的行为。

在代码较简单的情况下，可以在每一个代码分支结束时手动释放资源。

但是当代码复杂起来，时间跨度拉长，变更了开发人员等情况下，某些代码分支没有释放资源而直接结束方法后。就会造成资源永久挂起、内存泄漏等问题。

比如一个简单的场景：现在有一个 500 行的函数，需要检查一个 bug，你发现是少做了一层判断，加上判断后，顺手写了个异常判断 `if err != nil { return }`，看上去是正常的操作吧，此时一旦前半部分有获取资源资源需要手动释放的情况，这里直接退出函数就会造成资源的泄漏。

同样的，反过来想，作为一个后来的代码维护者，在修改代码时，同样要注意检查是否有需要手动释放的资源。

### 隔离程序

隔离程序指的是对于防御性编程的灵活调整，毕竟防御性编程始终是有成本的。而**绝对防御**式编程将消耗大量的精力，造成非常臃肿的代码。

所以我们可以将高危、容易出错的地方加上防御性编程代码，而在不容易出错的、内部的位置减少或去掉防御性编程代码。

⽽在内部的函数调⽤等地⽅，可以适当的减少防御性代码，但某些关键数据和关键逻辑位置，防御性代码依然是必要的。

![隔离程序](/images/go/隔离程序.png)

