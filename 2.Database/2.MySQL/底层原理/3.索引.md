# MySQL 索引

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

## 索引模型

### 1. 常见索引模型

常见的三种索引模型分别是哈希表、有序数组和搜索树。

- 哈希表：由于哈希表存储数据是无序的，所以适用于等值查询，不适用于范围查询，效率很低。
- 有序数组：由于是有序的，等值查询可以用二分法，所以等值查询和范围查询都适合。但更新数据效率很低。
- 搜索树：根据搜索需求逐渐演变，从二叉树到 N 叉树。N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

## InnoDB 索引模型

在 InnoDB 中，表根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。同时，InnoDB 使用了 B+ 树索引模型，所以数据都存储在 B+ 树中。

每一个索引在 InnoDB 里面对应一棵 B+ 树。

### 1. 主键索引和普通索引

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（`clustered index`）。

- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（`secondary index`）。

**基于主键索引和普通索引的查询区别：**

- 如果语句是 `select * from T where ID=500`，即主键查询方式，则只需要搜索 ID 这棵 B+ 树。
- 如果语句是 `select * from T where k=5`，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，在应用中应该尽量使用主键查询。

**为什么要使用自增主键：**

- 每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

  而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

- 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

### 2. 覆盖索引

如果查询的值已经在索引树上了，则可以直接提供查询结果，不需要回表，可以减少数的搜索次数。这种情况被称为覆盖索引，是一种常用的性能优化手段。

而通过联合索引，可以将需要查询的值放到索引上，用于加速查询效率。

例如，如果要根据市民的身份证号查询他的姓名，那么可以建立一个（身份证号、姓名）的联合索引。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

### 3. 最左前缀

B+ 树中，索引项是按照索引定义里面出现的字段顺序排序的。由于 B+ 树这种索引结构，可以利用索引的`最左前缀`，来定位记录。

这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。只要满足最左前缀，就可以利用索引来加速检索。

**如何安排联合索引字段顺序？**

评估标准是，索引的复用能力。

因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

### 4. 索引下推

在搜索时，如果满足最左前缀原则，则可以直接在索引上定位记录。

在 MySQL 5.6 之前，如果有不满足最左前缀原则的搜索条件，只能先根据最左前缀索引找出所有匹配的记录，然后逐条数据开始一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（`index condition pushdown`)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再开始回表查询，减少了回表次数。

