# 数据结构

## 一、数组 array

数组是同一类型元素的集合。

长度也是固定的，不允许数组混合不同类型的元素。

### 1. 声明

数组的表现形式为`[n]Type`

```go
var a [3]int
```

- 声明了一个长度为3，类型为int的数组
- 数组中的所有元素会被自动赋值为数据类型的零值
- 数组的索引从0开始
- 数组的大小是类型的一部分，不同大小的数组视为不同类型
- Go中的数组是值类型而不是引用类型，当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本

声明时赋值：

```go
var a = [3]int{12, 78, 50}
a := [3]int{12, 78, 50}
a := [5]int{1:12, 3:78}
a := [...]int{12, 78, 50}  // 自动计算长度
```

### 2. 多维数组

```go
a := [3][2]string{
    {"lion", "tiger"},
    {"cat", "dog"},
    {"pigeon", "peacock"},
}
```

## 二、切片 slice

切片可以理解为一个可变长度的数组。

切片本质上是对数组建立的方便、灵活且功能强大的封装（`Wrapper`）。

切片本身不存储任何数据，数据存储在底层的数组中，切片只是对数组的引用。对切片所做的任何修改都会反映在底层数组中。

### 1. 声明

切片的表现形式为 `[]Type`。

```go
c := []int{6, 7, 8}
```

使用已有数组创建切片。

```go
a := [5]int{76, 77, 78, 79, 80}
var b []int = a[1:4]
```

使用 make 创建切片，三个参数是类型、长度、容量，容量是可选参数，默认值与长度相同。

```go
c := make([]int, 5, 5)
```

- 使用 `make` 创建空切片时，一般长度使用 0，但是最好指定容量信息，避免后续追加内容时容量不足，造成频繁的内存分配

  ```go
  for n := 0; n < b.N; n++ {
    data := make([]int, 0, size)
    for k := 0; k < size; k++{
      data = append(data, k)
    }
  }
  ```

### 2. 空切片

切片还有 nil 切片和空切片，它们的长度和容量都是 0，但是它们指向底层数组的指针不一样

- nil 切片意味着指向底层数组的指针为 nil，表示切片不存在

  ```go
  var nilSlice []int  // nil 切片
  ```

- 而空切片对应的指针是个地址，一般用来表示这是一个空集合，没有内容

  ```go
  slice := []int{}  // 空切片
  ```

### 2. 长度和容量

- 长度使用 `len()` 查看，是切片中元素的数量。访问超过长度的索引值会报错。
- 容量使用 `cap()` 查看，是指创建切片时，底层数组的元素数量。容量必须大于等于长度。

### 3. 添加元素

使用`append()`方法

```go
var a []int
append(a, 10)
append(a, 20, 30, 40)

veggies := []string{"potatoes", "tomatoes", "brinjal"}
fruits := []string{"oranges", "apples"}
food := append(veggies, fruits...)
```

使用 `append()` 方法时，如果添加元素后的数量超过了切片的容量，那么 Go 会自动创建一个容量翻倍的底层数组，并将原有数组的数据复制到新的数组中，这样就实现了切片的动态长度。

注意：最好预先定好切片的大概长度，避免频繁的重新分配数组，浪费系统性能。

### 4. 拷贝

切片中保存的是对底层数组的引用，所以赋值给其他变量后，修改的依然是原数组。

如果有对某个数组的切片存在，那么原数组就不会被垃圾回收。

使用 `copy()` 函数可以生成一个与原切片无关的切片副本。

```go
countries := []string{"USA", "Singapore", "Germany", "India", "Australia"}
neededCountries := countries[:len(countries)-2]
countriesCpy := make([]string, len(neededCountries))
copy(countriesCpy, neededCountries)
```

## 三、映射 map

- `Map` 与切片相同，是引用类型

- `Map` 之间不能使用 `==` 操作符进行判断，`==` 只能用来检查 `Map` 是否为 `nil`

### 1. 声明

其表示方式为 `map[key type]value type`，如 `map[string]int`

```go
m := map[string]int{}
var m = map[string]int{"hunter":12,"tony":10}
m := make(map[string]int)
```

- 与切片相同，使用 `make` 创建 map 时，最好指定容量信息，避免后续追加内容时容量不足，造成频繁的内存分配

  ```go
  files, _ := ioutil.ReadDir("./files")
  
  m := make(map[string]os.FileInfo, len(files))
  for _, f := range files {
      m[f.Name()] = f
  }
  ```


### 2. 取值

取值方式为 `map[key]`，如果取一个不存在的值的话，那么会返回相应的数据类型的零值。

如果我们希望知道 `Map` 中到底存不存在这个值，我们可以使用以下语法

```go
value, ok := map[key]
```

### 3. 删除元素

删除 `Map` 中的元素可以使用 `delete(map, key)` 函数，此函数没有返回值。

```go
delete(person, "steve")
```

