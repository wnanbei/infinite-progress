# 动态规划之背包问题

## 类型

### 1. 0-1背包问题

给定一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。

- 其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`

现在让你用这个背包装物品，最多能装的价值是多少？

## 题解

### 1. 分割等和子集

Leetcode: [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给定一个只包含正整数的非空数组 `nums`，判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```go
func canPartition(nums []int) bool {
	sum := 0
	for _, v := range nums {
		sum += v
	}
	if sum%2 != 0 {
		return false
	}

	m := len(nums)
	n := sum / 2
	dp := make([]bool, n+1)
	dp[0] = true

	for i := 0; i < m; i++ {
		for j := n; j >= 0; j-- {
			if j >= nums[i] {
				dp[j] = dp[j] || dp[j-nums[i]]
			}
		}
	}

	return dp[n]
}
```

### 2. 零钱兑换 II

Leetcode: [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给定一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 amount 表示总金额。

计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0。

- 每一种面额的硬币有无限个。 

```go
func change(amount int, coins []int) int {
	m := len(coins)
	dp := make([]int, amount+1)
	dp[0] = 1

	for i := 1; i <= m; i++ {
		for j := 1; j <= amount; j++ {
			if j >= coins[i-1] {
				dp[j] += dp[j-coins[i-1]]
			}
		}
	}

	return dp[amount]
}
```

