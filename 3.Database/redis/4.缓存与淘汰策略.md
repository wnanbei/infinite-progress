## 缓存

### 1. 缓存类型

缓存的类型分为：本地缓存、分布式缓存和多级缓存。

1. `本地缓存`，本地缓存就是在进程的内存中进行缓存。

   本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。
   
2. `分布式缓存`

   分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。

   缺点就是需要进行远程请求，性能不如本地缓存。

3. `多级缓存`

   实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。

   在目前的一线大厂中，这也是最常用的缓存方案，单考单一的缓存方案往往难以撑住很多高并发的场景。

## 淘汰策略

### 1. 定期删除

redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，定期遍历这个字典来删除到期的 key。

Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。

1. 从过期字典中随机取 20 个 key
2. 删除这 20 个 key 中已经过期的 key
3. 如果过期的 key 比率超过 1/4，重复步骤 1

此策略主要避免了当 Redis 数据量太大时，每次过期检测需要遍历所有设置了过期时间的 key，造成 cpu 负载过大的问题。

### 2. 惰性删除

惰性策略就是在客户端访问这个 key 的时候，对 key 的过期时间进行检查，如果过期了就立即删除，不会返回任何东西。

定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。

### 3. 内存淘汰策略

由于定期删除和惰性删除策略，并不是所有的过期 key 都会被删除，所以需要内存淘汰策略进行补充。

Redis 4.0 以前有 6 种内存淘汰策略：

1. `noeviction`：当内存使用超过配置的时候会返回错误，不会驱逐任何键

2. `allkeys-lru`：加入键的时候，如果过限，首先通过 LRU 算法驱逐最久没有使用的键

3. `volatile-lru`：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键

4. `allkeys-random`：加入键的时候如果过限，从所有 key 随机删除

5. `volatile-random`：加入键的时候如果过限，从过期键的集合中随机驱逐

6. `volatile-ttl`：从配置了过期时间的键中驱逐马上就要过期的键

Redis 4.0 后新增了两种 lfu 策略：

7. `volatile-lfu`：从所有配置了过期时间的键中驱逐使用频率最少的键

8. `allkeys-lfu`：从所有键中驱逐使用频率最少的键

### 4. LRU

`LRU(Least Recently Used)` 最近最少算法用于计算淘汰最久没有使用过的 key，但 Redis 没有使用标准 LRU 实现，而是使用了一种近似的 LRU 实现方式。

#### 标准 LRU

标准的 LRU 算法使用一个双向链表来记录数据的最近被访问顺序。

1. 新增 key 时，在链表结尾添加 node，如果超出 LRU 阈值，淘汰链表队头的 node
2. 修改 key 时，先修改对应 node 的值，然后把 node 移动到链表队尾
3. 访问 key 时，将 node 移动到链表队尾

#### Redis LRU 实现

Redis 在每一个 key 对象内部维护了一个以秒为单位的 24 位时间戳，通过对少量 key 进行采样（默认 5 个），对比时间戳，然后回收其中最久未被访问的 key。

需要注意的是此时间戳最大只能表示 194 天，不过这对于更新频繁的缓存数据来说是够用的。

Redis 中有三个配置和 LRU 有关：

- `maxmemory`: `Redis` 存储数据时限制的内存大小，比如 `100m`。超过这个数值时触发数据淘汰。此配置为 0 时，不限制内存量。64 位的系统默认值为 0，32 位的系统默认内存限制为 3GB。
- `maxmemory_policy`: 触发数据淘汰后的淘汰策略。
- `maxmemory_samples`: 随机采样的精度，也就是随机取出 key 的数目。该数值配置越大, 越接近于真实的 LRU 算法，但是数值越大，相应消耗也变高，对性能有一定影响，样本值默认为 5。

**Redis 3.0 LRU 优化：**

优化后算法会维护一个候选池，大小为 16，池中的数据根据访问时间进行排序，第一次采样选取的 key 都会放入池中。

- 随后每次随机选取的 key 只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。

- 池放满后，如果有新的 key 需要放入，则将池中最近被访问的移出池。

- 需要淘汰数据的时候，直接从池中选取最久没被访问的 key 淘汰掉。

#### 为什么不使用标准 LRU

1. 原生 LRU 算法需要双向链表来管理数据，需要更多的内存

2. 原生 LRU 需要对所有 key 进行排序，性能损耗更高

3. 如果请求符合长尾法则，那么真实 LRU 与 Redis LRU 之间表现基本无差异，实际效果基本相等

4. 需要改造现有 Redis 数据结构

   据 Redis 作者说，每个 Redis Object 可以挤出 `24 bits` 空间，但 24 bits 不够存储两个指针，但可以存储一个低位时间戳。

![Redis LRU 算法性能](../../assets/Redis%20LRU%20%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD.webp)

### 5. LFU

使用 LRU 算法，有可能一个 key 很久没有被访问，只刚刚偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些 key 将来是很有可能被访问到但被淘汰了。

Redis 在 4.0 中新增了一种 LFU 淘汰策略，用于根据 key 的访问频率进行淘汰。

**实现方式：**

- LFU 使用跟 LRU 同样的 24 bits 字段记录数据。LFU 算法中，前 16 bits 用于记录以分钟为单位的时间，后 8 bits 记录访问频率，最大为 255。
- 

## 数据持久化

redis 提供了两种持久化的方式，分别是 `RDB(Redis DataBase)` 和 `AOF(Append Only File)`。

### 1. RDB

RDB，就是在不同的时间点，将 redis 存储的数据生成快照并存储到磁盘等介质上。

Redis 在进行 RDB 数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程结束，才会用这个临时文件替换上次持久化好的文件。这种特性，让我们可以随时进行备份，因为快照文件总是完整可用的。

**优点：**

- Redis 会单独 fork 一个子进程进行持久化，不影响主进程性能。
- 大规模数据恢复更高效。
- 备份文件总是完整可用。

**缺点：**

- RDB 耗时较长，不够实时，在停机的时候会导致大量丢失数据。数据完整性较差。

### 2. AOF

AOF，则是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，把这些写指令从前到后再重复执行一遍，实现数据恢复。开启 AOF 后，如果有写操作，如 SET 等，redis 就会追加到 AOF 文件的末尾。

默认的 AOF 持久化策略是每秒钟 fsync（指把缓存中的写指令记录到磁盘中）一次，因为在这种情况下，redis 仍然可以保持很好的处理性能，即使 redis 故障，也只会丢失最近 1 秒钟的数据。

**优点：**

- 丢失数据的可能性小。
- 有 Rewrite 机制可以控制 AOF 文件大小。
- 断电、磁盘满等问题都不会影响 AOF 文件的可用性。

**缺点：**

- AOF 文件会越来越大，占用较多空间。
- 数据恢复效率较慢。

### 3. AOF Rewrite

Redis 提供了 AOF 文件重写（rewrite）机制，当 AOF 文件的大小超过所设定的阈值时，redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。

例如调用了 100 次 INCR 指令，在 AOF 文件中可以用 rewrite 把这 100 条指令合并成一条 SET 指令。

**流程：**

1. redis 会创建（fork）一个重写子进程，首先读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。
2. 同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。
3. 当重写子进程完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中。
4. 追加结束后，redis 就会用新 AOF 文件来代替旧 AOF 文件。

### 4. 恢复数据

因为 RDB 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以通常需要 AOF 配合同时使用。

在 Redis 实例重启时，使用 RDB 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。

## 集群