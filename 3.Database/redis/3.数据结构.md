在 Redis 中，常用的 5 种数据类型和应用场景如下：

- `String`：缓存、计数器、限速器、分布式锁等。
- `List`：链表、队列、微博关注人时间轴列表等。
- `Hash`： 用户信息、Hash 表等。
- `Set`： 去重、赞、踩、共同好友等。
- `Zset`：访问量排行榜、点击量排行榜等。

不同数据类型使用不同的数据结构以提升速度。每种数据类型都有一种或者多种数据结构来支撑，底层数据结构有 6 种。

![Redis底层数据结构类型](../../assets/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B.webp)

使用以下命令可以查看 Key 具体的编码方式：

```redis
> object encoding key
```

## redisObject

Redis 有一个核心的对象 `redisObject`，用来表示所有的 key。

此对象中有类型和编码两个字段，用来表示 key 的类型和底层数据结构。

![redis数据结构编码](../../assets/redis数据结构编码.jpg)

## SDS String

SDS，全称 `Simple Dynamic String`。

在 Redis 中，包含字符串值的键值对都是由 SDS 实现的，而不是 C 语言自带的字符串。SDS 字符串适合用来表示可以被修改的字符串。

**优势：**

- 计算长度的时间复杂度为 O(1)
- 二进制安全
- 减少修改操作的内存重分配次数
- 杜绝缓冲区溢出

**劣势：**

- 占用更多内存，并且这些内存不会被主动释放

### 1. Redis 字符串编码

字符串对象的值实际可以是字符串、数字、甚至是二进制，最大不能超过 512MB。

字符串对象的内部编码有 3 种：`int`、`raw` 和 `embstr`。

1. 如果字符串对象保存的是可以用 `long` 类型表示的整数值，那么 Redis 会将整数值保存在字符串对象的 `ptr` 属性中，并将编码设置为 `int`。
2. 如果字符串对象保存的是一个字符串值，并且长度大于 32 字节，那么 Redis 将使用一个简单动态字符串 `SDS` 来保存，并将编码设置为 `raw`。
3. 如果字符串对象保存的是一个字符串值，并且长度小于等于 32 字节，那么 Redis 将使用一个简单动态字符串 `SDS` 来保存，并将编码设置为 `embstr`

`embstr` 编码是专门用于保存短字符串的一种优化编码方式，`raw` 编码会通过调用两次内存分配函数来分别分配两块空间来保存 `redisObject` 和 `SDS`，而 `embstr` 的不同之处在于会分配一块连续的内存空间来保存 `redisObject` 和 `SDS`。

`embstr` 编码的优点有以下几点：

- `embstr` 编码创建字符串对象所需的内存分配次数为一次
- `embstr` 编码的字符串对象释放内存也只需要调用一次内存释放函数
- `embstr` 编码的字符串对象的所有数据都保存在一块连续的内存里，可以更好的利用 CPU 缓存提升性能

### 2. 数据结构

sds 的完整结构分为两块部分，`sdshdr` 结构和字符数组。

![SDS 数据结构](../../assets/Redis sds.jpg)

- `len` - sds buffer 的已用长度。小于等于 alloc，len 根据类型可以分为无符号的 8 位、16 位、32 位、64 位的整数。

- `alloc` - sds buffer 分配的内存空间的总长度。alloc 根据类型可以分为无符号的 8 位、16 位、32 位、64 位的整数。

- `flags` - sds 的类型。取值范围为 0-4，用来表示 sds 的五种类型：5位、8 位、16 位、32 位、64 位，其中 0 表示的 5 位类型实际上并没有用到。

  类型根据 buffer 的总长度来决定，比如 8 位类型，buffer 的最大长度为 255。

  当表示 5 位的 `sdshdr5` 时，前三位用于表示类型，后五位用于存储字符串内容，此时没有 `buf[]` 部分。

- `buf[]` - 字符数组，实际存储字符串的地方。buffer 由三部分组成：`used buffer`、`avai buffer`、`end`。

- `used buffer` - 已经使用的 buffer。长度由 len 表示。

- `avai buffer` - 剩余可用的 buffer。长度等于 alloc - len。

- `end` - 表示 buffer 的结尾。占用 8 位空间，等同于 `/0`。

注：Redis 3.2 以前，SDS 使用 len 和 free 两个 4 字节的参数来表示字符串的大小。Redis 3.2 之后，SDS 字符串按长度划分成 5 种不同的类型，增加了一个 1 字节大小的 flags 字段表示类型，这样在存储短字符串时，len 和 alloc 可以被缩短到 1 字节。这是 Redis 节省内存的设计。

### 3. 扩容与释放

SDS 的空间预分配策略：

1. 若 SDS 中剩余空闲长度 avail 大于或等于新增内容的长度 addlen，无需扩容。
2. 若 SDS 中剩余空闲长度 avail 小于或等于 addlen，则分情况讨论：
   - 新增后总长度 `len+addlen < 1MB` 的，按新长度的 2 倍扩容
   - 新增后总长度 `len+addlen >= 1MB` 的，按新长度加上 `1MB` 扩容。

SDS 的惰性释放策略：

1. 当 SDS 的长度缩短时，Redis 并不会立即回收不再使用的内存空间，而是更新 len 属性，需要时使用 `alloc-le`n 即可获知未被使用的空间大小。
2. 目的是避免频繁的内存分配，但会造成部分内存的浪费。
3. Redis 也提供了主动释放未使用内存的方法。

## HashTable

Redis 的 HashTable 使用 `MurmurHash2` 算法计算 Hash 值。

`HashTable` 类型的数据结构主要应用在三个地方：

- 全局 Hash 表
- Hash 对象，需满足以下两个条件
  1. 当 Hash 对象元素个数大于 `hash-max-ziplist-entries` 配置，默认 512 个
  2. 当有值大于 `hash-max-ziplist-value` 配置，默认 64 字节
- Set 对象

**优势：**

- 访问数据的时间复杂度为 O(1)

**劣势：**

- 有哈希冲突问题

![字典数据结构](../../assets/Redis Hash Table.jpg)

### 1. 链表法

Redis 中的 HashTable 使用链表法解决 Hash 冲突问题。**也就是同一个桶里面的元素使用链表保存**。

但是当链表过长就会导致查找性能变差可能，所以 Redis 的字典都使用了两个 HashTable 用于 Rehash 操作，增加现有的哈希桶数量，减少哈希冲突。

一般情况下，字典只使用 `ht[0]` HashTable, `ht[1]` HashTable 只在进行 Rehash 时使用。

### 2. 负载因子

负载因子用于衡量 HashTable 的“健康状况”。

> HashTable 的负载因子 = 填入 HashTable 中的元素个数 / HashTable 的长度

对于 HashTable 来说，负载因子过大或过小都不好，

- 负载因子过大，代表空闲位置越少，冲突也就越多，散列表的性能会下降
- 负载因子过小，则会造成内存不能合理利用，从而形成内存浪费

因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即 `Rehash`，类似于数组的收缩与扩容。

### 3. Rehash

**Rehash 执行条件**

在满足以下条件之一时，将进行 Rehash 操作：

- 负载因子大于等于 1 且 `dict_can_resize` 设置为 1，执行扩容操作
- 负载因子小于 `0.1`，执行收缩操作

当服务正在执行 `BGSAVE` 命令或者 `BGREWRITEAOF` 命令进行持久化操作时，Redis 不会进行 Rehash 操作，除非满足以下条件：

- 负载因子大于等于安全阈值 `dict_force_resize_ratio`，默认为 5 时，将无视持久化操作，强制执行 Rehash 扩容操作

**Rehash 过程**

扩展 HashTable 和收缩 HashTable 都是通过执行 Rehash 来完成，主要经过以下五步：

1. 为 `ht[1]` 分配空间，其大小取决于 `ht[0]` 已使用节点数，即 `ht[0].used`

   - 扩展操作，`ht[1]` 的大小为第一个大于等于 `ht[0].used * 2` 的 $2^n$

     如：`ht[0].used=3` 则 `ht[1]` 的大小为 8，`ht[0].used=5` 则 `ht[1]` 的大小为 16

   - 收缩操作， `ht[1]` 的大小为第一个大于等于 `ht[0].used` 的 $2^n$​

2. 将字典的 `rehashidx` 设置为 0，表示正在执行 rehash 操作
3. 将 `ht[0]` 中所有的键值对依次重新计算哈希值，并放到 `ht[1]` 数组对应位置，完成一个键值对的 Rehash 之后`rehashidx` 的值加 1
4. 当 `ht[0]` 中所有的键值对都迁移到 `ht[1]` 之后，释放 `ht[0]`，将 `ht[1]` 修改为 `ht[0]`，然后再创建一个新的 `ht[1]` ，为下一次 Rehash 做准备。
5. 将字典的 `rehashidx` 设置为 -1，表示 rehash 已经结束

### 4. 渐进式 Rehash

由于 Rehash 过程需要完全重新计算整个 HashTable 的所有数据，需要的计算量非常庞大，所以 Redis 将 Rehash 过程分成多步进行，这被称为渐进式 Rehash。

渐进式 Rehash 以 bucket 为单位进行数据迁移：

- Redis 执行每一个增删查改命令时都会检测是否处于 Rehash 过程中，如果是则帮助执行一次渐进式 Rehash 的数据迁移
- 同时，Redis 的周期函数如果发现有字典处于 Rehash 过程中，也会帮助执行一次渐进式 Rehash 的数据迁移，此行为需要配置 `activerehashing`，默认值为 1

在渐进式 Rehash 的过程中，会同时使用两个 HashTable

- Delete、Find、Update 操作会优先从 `ht[0]` 查找，如果找不到再从 `ht[1]` 查找
- 而插入操作则只会插入到 `ht[1]` 中

这就保证了随着 Rehash 过程的进行，`ht[0]` 的数据只减不增，最终变成一张空表。

## ZipList

压缩数组 `ziplist` 是为了节省内存而开发的一种数据结构，由一系列特殊编码的连续内存块组成的顺序型数据结构。

`ziplist` 不存储指向上一个节点和下一个节点的指针，存储的是上一个节点的长度和当前节点的长度，牺牲了部分读写性能来换取高效的内存利用率，是一种时间换空间的思想。

`ZipList` 类型的数据结构主要应用在以下位置：

- List
- Hash 对象，需满足以下两个条件
  1. 当 Hash 对象元素个数小于 `hash-max-ziplist-entries` 配置，默认 512 个
  2. 当所有值小于 `hash-max-ziplist-value` 配置，默认 64 字节
- Sorted Set

**优势：**

- 使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面比 HashTable 更加优秀

**劣势：**

- 只适用于字段个数少和字段值少的场景
- 连锁更新问题

### 1. 数据结构

![ZapList 数据结构](../../assets/Redis ZapList.png)

- `zlbytes` - uint32_t 4字节

  记录整个 zaplist 占用内存字节数，包括本身所占用的 4 个字节。在对 ziplist 进行内存重分配，或计算 zlend 位置时使用。

- `zltail` - uint32_t 4字节

  记录 zaplist 尾节点距离 zaplist 起始地址有多少个字节。通过这个值无需遍历整个 zaplist 就可以计算出尾节点的地址。

- `zllen` - uint16_t 2字节

  记录 zaplist 中包含的节点数量，当超过可以存储的最大值 65535 时，此值固定为 65535，此时需要遍历整个 zaplist 才能计算出真实节点数。

- `entry` - 列表节点

  存储 zaplist 中的内容，长度由存储的实际数据决定。

- `zlend` - uint8_t 1字节

  用于标记 zaplist 的末端。

### 2. 节点

zaplist 的节点可以存储两种数据，整数或者字节数组。

![ZapList 数据结构](../../assets/Redis ZapList Entry.png)

`zaplist` 的每个节点分为三部分：

- `previous_entry_length` - 前一个 entry 的长度，以便能够从后到前遍历列表

  1. 如果前一节点的长度小于 254 字节,那么 previous_entry_length 属性的长度为 1 字节，前一节点的长度就保存在这一个字节里面。

  2. 如果前一节点的长度大于等于 254 字节,那么 previous_entry_length 属性的长度为 5 字节。

     其中第一个字节会被设置为 0xFE(十进制值254)，标记后面跟了一个更大的值。

     之后的四个字节则用于保存前一节点的长度。

- `encoding` - 当前 entry 所保存数据的类型以及长度

  1. 当存储的数据是 0-12 范围的小整数时，数据会直接存储到 encoding 中，此时节点将不再会有 content 部分。

- `content` - 具体数据

### 3. 时间复杂度

| 操作                                                         | 时间复杂度                                     |
| :----------------------------------------------------------- | ---------------------------------------------- |
| 创建一个新的 zaplist                                         | O(1)                                           |
| 获取给定节点所保存的值                                       | O(1)                                           |
| 返回给定节点的下一个节点                                     | O(1)                                           |
| 返回给定节点的前一个节点                                     | O(1)                                           |
| 返回 zaplist 给定索引上的节点                                | O(N)                                           |
| 返回 zaplist 目前占用的内存字节数                            | O(1)                                           |
| 创建一个包含给定值的新节点,并将这个新节点添加到 zaplist 的表头或者表尾 | 平均O(N)，最坏O(N^2)(可能发生连锁更新)         |
| 将包含给定值的新节点插人到给定节点之后                       | 平均O(N)，最坏O(N^2)(可能发生连锁更新)         |
| 从 zaplist 中删除给定的节点                                  | 平均O(N)，最坏O(N^2)(可能发生连锁更新)         |
| 删除 zaplist 在给定索引上的连续多个                          | 平均O(N)，最坏O(N^2)(可能发生连锁更新)         |
| 返回 zaplist 目前包含的节点数量                              | 数量小于 65535 时为 O(1)，大于 65535 时为 O(N) |
| 在 zaplist 中査找并返回包含了给定值的节点                    | 因为节点的值可能是一个字节数组，所以检查节点值和给定值是否相同的复杂度为O(N)，而查找整个列表的复杂度则为(N^2) |


## IntSet