## 两数之和

给定一个整数数组 `nums` 和一个目标值 `target`，在该数组中找出和为目标值的那`两个`整数，并返回他们的数组下标。

可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

> 给定 nums = [11, 2, 7, 15], target = 9
>
> 因为 nums[1] + nums[2] = 2 + 7 = 9
> 所以返回 [1, 2]

### 1. 暴力枚举

枚举数组中的每一个数 `x`，寻找数组中是否存在 `target - x`。

当使用遍历整个数组的方式寻找 `target - x` 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。

而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

**复杂度**

- 时间复杂度：*O*(N^2^)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。
- 空间复杂度：*O*(1)。

```go
func twoSum(nums []int, target int) []int {
    for i, x := range nums {
        for j := i + 1; j < len(nums); j++ {
            if x+nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
```

### 2. Hash

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 `O(N)` 降低到 `O(1)`。

创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，不存在则将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

**复杂度**

时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。

空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。

```go
func twoSum(nums []int, target int) []int {
    hashTable := map[int]int{}
    for i, x := range nums {
        if p, ok := hashTable[target-x]; ok {
            return []int{p, i}
        }
        hashTable[x] = i
    }
    return nil
}
```

